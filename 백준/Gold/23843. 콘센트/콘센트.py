n, m = map(int, input().split())
electronics = list(map(int, input().split()))

from heapq import heappop, heappush

def solution(n, m, electronics):
    # n개의 전자기기를 모두 충전해야한다.
    # 각 전자기기는 2^n만큼의 시간이 걸린다.
    # m개의 콘서트를 이용해서 충전을 한다.
    # 목표: 충전시간을 줄이려면 어떻게 해야할까?
    # 콘서트가 1개인 경우에는 차례로 충전을 해야한다. 따라서 별다른 고려할 필요 없음.
    # 콘서트가 2개 이상인 경우, 예를 들어 2 4 8 의 전자기기가 있다고 생각하자

    # 충전시간이 짧은 것부터 충전을 했다. 모든 전자기기가 충전되는데 걸리는 시간은 11초이다.
    # 0초 1초 2초 3초 4초 5초 6초 7초 8초 9초 10초 11초
    # 시작    완료 시작                          완료
    # 시작           완료

    # 충전시간이 긴 것부터 충전을 했다. 모든 전자기기가 충전되는데 걸리는 시간은 8초이다.
    # 0초 1초 2초 3초 4초 5초 6초 7초 8초 9초 10초 11초
    # 시작                         완료
    # 시작           완료 시작    완료

    # 위의 예시에서는 충전 시간이 긴 것부터 충전을 했을 때 더 걸리는 시간이 짧았다.
    # 왜 이런 일이 벌어졌을까?
    # 콘센트가 2개이상인 경우에는 병렬적으로 충전이 가능하다. 따라서 긴 것을 충전하고 있는 동안
    # 다른 콘센트에서 짧은 애들이 충전되면 긴 것과 같이 충전되게 된다.
    # 문제는 짧은 것들은 먼저하는 경우 긴 충전시간을 가진 전자기기 홀로 충전되고 있어서 시간이 길어질 수밖에 없다.

    # 따라서 이 문제는 충전시간이 긴 전자기기부터 충전을 해야한다.

    # 문제의 예시
    # 0초 1초 2초 3초 4초 5초 6초 7초 8초 9초 10초 11초
    # 시작                         시작 완료
    # 시작           시작           시작 완료

    # 충전시간이 한 개당 최대 2^15이므로 시간에 따른 전수조사할 생각하면 절대 안된다.
    
    # 충전이 긴 것부터 가져와야하므로 우선순위큐를 사용한다.
    # 시간복잡도 O(nlogn)
    max_heap = []
    for electronic in electronics:
        heappush(max_heap, -electronic)

    # 소켓의 수는 최대 10개
    # 전자기기를 연결할 때 소켓의 숫자가 작은 쪽에 연결하고 같다면 인덱스가 적은 쪽으로 연결하겠다!
    sockets = [0] * m

    # 시간복잡도 계산
    # O(nlogn) * O(m)
    while max_heap:
        elc = -heappop(max_heap)
        idx = sockets.index(min(sockets))
        sockets[idx] += elc

    return max(sockets)


print(solution(n, m, electronics))